\documentclass[10pt, oneside]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{titling}
\usepackage[nottoc, notlof]{tocbibind}
\usepackage[pdftex]{graphicx}
\usepackage[kerning,spacing]{microtype}
\usepackage{verbatim}
\usepackage{tikz}
\usetikzlibrary{arrows}

\usepackage[bookmarksnumbered, unicode, pdftex]{hyperref}

\author{Mikhail Glushenkov, \texttt{<c05mgv@cs.umu.se>}\\
        Bertil Nilsson, \texttt{<id09bnn@cs.umu.se>}}

\title{Assignment 2 -- GCom Middleware:\\Analysis and Design}

\newcommand{\unit}[1]{\ensuremath{\, \mathrm{#1}}}

\begin{document}
\pagestyle{plain}
\pdfbookmark[1]{Front page}{beg}

\begin{titlingpage}
  \begin{minipage}[t]{0.45\textwidth}
  \begin{flushleft}
  \texttt{5DV020 - Distributed Systems, Autumn 12}
  \end{flushleft}
  \end{minipage}
  \begin{minipage}[t]{0.4\textwidth}
  \begin{flushright}
  \texttt{Umeå University}
  \end{flushright}
  \end{minipage}
  \vskip 60pt
  \begin{center}
  \LARGE\thetitle
  \par\end{center}\vskip 0.5em
  \begin{center}
  \large\theauthor
  \par\end{center}
  \begin{center}
  Date: \today
  \par\end{center}
  \vfill
  \begin{center}
    \textbf{Instructors} \linebreak \linebreak
    Francisco Hernandez-Rodriguez\\
    Ewnetu Bayuh Lakew
  \end{center}
\end{titlingpage}

% TOC
%\thispagestyle{empty}
%\pagebreak
%\setcounter{page}{0}
%\pdfbookmark[1]{Table of contents}{tab}
%\tableofcontents
\pagebreak

% % i Sverige har vi normalt inget indrag vid nytt stycke
\setlength{\parindent}{0pt}
% men däremot lite mellanrum
\setlength{\parskip}{10pt}

\setcounter{section}{-1}

\section{Introduction}

The purpose of this assignment is to design and implement GCom, a middleware for
group communication. Middleware is a software layer that provides a high-level
interface to some functionality and frees the user from worrying about how said
functionality is implemented. Group communication is a mode of communication
that allows a set of nodes distributed over network to form groups and broadcast
messages to all members of the groups they belong to.

This is the first report, written at the planning stage of the project. It
contains a requirements specification, a description of the design and a time
plan.

\section{Requirements Specification}

This assignment is divided into three levels - the obligatory basic level and
two bonus levels that give additional points. In addition to the basic level,
our solution will also implement the first bonus level (dynamic groups).

The GCom middleware consists of three logical modules: communication, message
ordering and group management. Additionally, we are required to implement a test
application for showcasing the features of the GCom middleware and a debug
application for demonstrating that it works correctly.

The communication module supports two operations: basic non-reliable multicast
and basic reliable multicast. The type of multicast and the message type are set
at module initialisation time, so only a single send operation is accessible at
runtime. This operation takes a set of nodes and a message as input, and blocks
until the operation has completed. The communication module also allows to
register callbacks for acting upon a message delivired to the current node.

The message ordering module is built on top of the communication module. It
allows to deliver messages according to several different orderings. The
following orderings must be supported: non-ordered, FIFO, causal, total and
causal-total (described in more detail in the assignment specification and in
the textbook\cite{Textbook}). Again, the type of ordering is set at module
initialisation time. Apart from this, this module has the same interface as the
communication module, if we don't take support for the debugging application
into account.

The group management module is the user-facing part of the system implemented on
top of the previous two modules. It allows to create and remove groups, add and
remove group members, handles the monitoring of live nodes, keeps track of
changes in group membership, and allows to list the names of all existing
groups.

The test program is a simple distributed GUI chat program in which each chat
client instance is a node of the distributed system.

The debug application is implemented as a special client for the aforementioned
chat system that allows to watch the inner workings of the middleware. It has
the following features:
\begin{itemize}
\item Simulated packet loss (send a message to a part of the group).
\item Simulated packet rearrangement (send several messages in random order to
  different nodes).
\item Creation of a group with a chosen message ordering and multicast type.
\item Display of the internal state of the system (such as message queues).
\item Measurement of system performance.
\end{itemize}

\section{Design}

We decided to implement our system in Scala and use Java RMI for communication
between nodes. The choice of Scala was motivated by the desire to use a language
that is more modern and convenient than Java, but still allows to run on
JVM. Java RMI was chosen because it was the default option (recommended in the
assignment specification) and we felt that other communication libraries that we
looked at either didn't provide any benefit for our use case (Finagle) or did
all the required work for us (ZeroMQ).

Design of the communication module: simple, just use the reliable multicast
algorithm from the textbook.

Design of the message ordering module:
\begin{itemize}
\item FIFO: timestamps
\item Causal: vector clocks
\item Total: sequencer node chosen with an election alfgorithm
\item Causal-Total: combination of causal and total
\end{itemize}

Design of the group management module:
\begin{itemize}
\item A node is identified by a (host, port) pair (or (host, name) for RMI).
\item A group is identified by a group name.
\item Group names are globally unique.
\item Each node knows all group names, but not members
\item Each node knows a distinguished group node for each group
\item Distinguished node resolves group name to the list of group members
\item If a distinguished node dies, a new distinguished node is elected and
  everyone is notified
\item Join a group: get a list of group members, broadcast a notification to
  group members.
\item Leave a group: broadcast a notification.
\item If a node notices that one of its peers has died: broadcast a notification
  to the members of all groups it belonged to.
\end{itemize}


\section{Time Plan}

Our preliminary plan looks as follows:

\begin{tabular}{|l|p{10cm}|}
  \hline
  Week 49 & Implement the communication module. Start working on implementing the
  Paxos algorithm. Start working on the GUI test programs. \\
  \hline
  Week 50 & Implement the message ordering module. Produce a finished version of the Paxos algorithm. \\
  \hline
  Week 51 & Integrate the code written during the first two weeks; produce an
  initial approximation of the final system. \\
  \hline
  Week 52 & Testing and bugfixing. Work on the test programs. Start writing the final report. \\
  \hline
  Week 1  & More testing and bugfixing. Time for any unforeseen delays. \\
  \hline
  Week 2  & Practical demonstration. Turn in the final report. \\
  \hline
\end{tabular}

\begin{thebibliography}{9}

\bibitem{Textbook} \emph{Distributed Systems}\\
\newblock George Coulouris, Jean Dollimore, Tim Kindberg and Gordon Blair\\
\newblock Addison-Wesley, 2011\\

\bibitem{Paxos} \emph{Paxos Made Simple}\\
\newblock Leslie Lamport\\
\newblock ACM SIGACT News (Distributed Computing Column) 32, 4 (Whole Number
121, December 2001) 51-58.\\

\end{thebibliography}


\end{document}
